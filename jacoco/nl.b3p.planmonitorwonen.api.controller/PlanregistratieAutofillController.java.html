<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlanregistratieAutofillController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Aggregate Test Coverage</a> &gt; <a href="index.source.html" class="el_package">nl.b3p.planmonitorwonen.api.controller</a> &gt; <span class="el_source">PlanregistratieAutofillController.java</span></div><h1>PlanregistratieAutofillController.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2024 Provincie Zeeland
 *
 * SPDX-License-Identifier: MIT
 */

package nl.b3p.planmonitorwonen.api.controller;

import static java.util.Comparator.comparingDouble;
import static org.springframework.http.HttpStatus.BAD_REQUEST;

import java.lang.invoke.MethodHandles;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;
import org.apache.commons.lang3.tuple.Pair;
import org.geotools.api.data.DataStore;
import org.geotools.api.data.DataStoreFinder;
import org.geotools.api.data.Query;
import org.geotools.api.data.SimpleFeatureSource;
import org.geotools.api.feature.simple.SimpleFeature;
import org.geotools.data.simple.SimpleFeatureIterator;
import org.geotools.data.wfs.WFSDataStoreFactory;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.GeometryFactory;
import org.locationtech.jts.geom.PrecisionModel;
import org.locationtech.jts.io.ParseException;
import org.locationtech.jts.io.WKTReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Profile;
import org.springframework.jdbc.core.simple.JdbcClient;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

@RestController
@Profile(&quot;!test&quot;)
public class PlanregistratieAutofillController
    implements ApplicationListener&lt;ApplicationReadyEvent&gt; {

  private static final Logger logger =
<span class="nc" id="L51">      LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());</span>

  private final JdbcClient jdbcClient;

  @Value(&quot;${planmonitor-wonen-api.wfs.bestuurlijke-gebieden}&quot;)
  private String bestuurlijkeGebiedenWfs;

  @Value(&quot;${planmonitor-wonen-api.wfs.bestuurlijke-gebieden.provincies-typename}&quot;)
  private String provinciesTypename;

  @Value(&quot;${planmonitor-wonen-api.wfs.bestuurlijke-gebieden.provincies-propertyname}&quot;)
  private String provinciesPropertyName;

  @Value(&quot;${planmonitor-wonen-api.wfs.timeout:5000}&quot;)
  private int wfsTimeout;

  @Value(&quot;${planmonitor-wonen-api.wfs.ruimte}&quot;)
  private String ruimteWfs;

  @Value(&quot;${planmonitor-wonen-api.wfs.ruimte.regios-typename}&quot;)
  private String regiosTypename;

  @Value(&quot;${planmonitor-wonen-api.wfs.ruimte.regios-propertyname}&quot;)
  private String regiosPropertyName;

  @Value(&quot;${planmonitor-wonen-api.wfs.ruimte.woonmilieu-typename}&quot;)
  private String woonmilieuTypename;

  @Value(&quot;${planmonitor-wonen-api.wfs.ruimte.woonmilieu-propertyname}&quot;)
  private String woonmilieuPropertyName;

<span class="nc" id="L82">  private final List&lt;SimpleFeature&gt; provincieFeatures = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L83">  private final List&lt;SimpleFeature&gt; regioFeatures = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L84">  private final List&lt;SimpleFeature&gt; woonmilieuFeatures = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L86">  public PlanregistratieAutofillController(JdbcClient jdbcClient) {</span>
<span class="nc" id="L87">    this.jdbcClient = jdbcClient;</span>
<span class="nc" id="L88">  }</span>

  @Override
  public void onApplicationEvent(ApplicationReadyEvent event) {
<span class="nc" id="L92">    Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();</span>
<span class="nc" id="L93">    params.put(WFSDataStoreFactory.TIMEOUT.key, wfsTimeout);</span>
<span class="nc" id="L94">    DataStore ds = null;</span>

    try {
<span class="nc" id="L97">      params.put(WFSDataStoreFactory.URL.key, bestuurlijkeGebiedenWfs);</span>
<span class="nc" id="L98">      ds = DataStoreFinder.getDataStore(params);</span>
<span class="nc" id="L99">      logger.info(&quot;Initialized datastore for bestuurlijke gebieden WFS &quot; + bestuurlijkeGebiedenWfs);</span>

<span class="nc" id="L101">      SimpleFeatureSource fs = ds.getFeatureSource(provinciesTypename);</span>
<span class="nc" id="L102">      Query query = new Query(provinciesTypename);</span>
<span class="nc" id="L103">      try (SimpleFeatureIterator features = fs.getFeatures(query).features()) {</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        while (features.hasNext()) {</span>
<span class="nc" id="L105">          provincieFeatures.add(features.next());</span>
        }
      }
<span class="nc" id="L108">      logger.info(&quot;Loaded provincie features&quot;);</span>
<span class="nc" id="L109">    } catch (Exception e) {</span>
<span class="nc" id="L110">      logger.error(&quot;Error loading provincies from WFS &quot; + bestuurlijkeGebiedenWfs, e);</span>
    } finally {
<span class="nc bnc" id="L112" title="All 2 branches missed.">      if (ds != null) {</span>
<span class="nc" id="L113">        ds.dispose();</span>
      }
    }

    try {
<span class="nc" id="L118">      params.put(WFSDataStoreFactory.URL.key, ruimteWfs);</span>
<span class="nc" id="L119">      ds = DataStoreFinder.getDataStore(params);</span>
<span class="nc" id="L120">      logger.info(&quot;Initialized datastore for ruimte WFS &quot; + ruimteWfs);</span>

<span class="nc" id="L122">      SimpleFeatureSource fs = ds.getFeatureSource(regiosTypename);</span>
<span class="nc" id="L123">      Query query = new Query(regiosTypename);</span>
<span class="nc" id="L124">      try (SimpleFeatureIterator features = fs.getFeatures(query).features()) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">        while (features.hasNext()) {</span>
<span class="nc" id="L126">          regioFeatures.add(features.next());</span>
        }
      }
<span class="nc" id="L129">      logger.info(&quot;Loaded ruimte features&quot;);</span>
<span class="nc" id="L130">      fs = ds.getFeatureSource(woonmilieuTypename);</span>
<span class="nc" id="L131">      query = new Query(woonmilieuTypename);</span>
<span class="nc" id="L132">      try (SimpleFeatureIterator features = fs.getFeatures(query).features()) {</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">        while (features.hasNext()) {</span>
<span class="nc" id="L134">          woonmilieuFeatures.add(features.next());</span>
        }
      }
<span class="nc" id="L137">      logger.info(&quot;Loaded woonmilieu features&quot;);</span>
<span class="nc" id="L138">    } catch (Exception e) {</span>
<span class="nc" id="L139">      logger.error(&quot;Error loading features from ruimte WFS &quot; + ruimteWfs, e);</span>
    } finally {
<span class="nc bnc" id="L141" title="All 2 branches missed.">      if (ds != null) {</span>
<span class="nc" id="L142">        ds.dispose();</span>
      }
    }
<span class="nc" id="L145">  }</span>

  private static List&lt;SimpleFeature&gt; getFeaturesOrderedByIntersectionAreaDescending(
      Geometry geometry, Collection&lt;SimpleFeature&gt; features) {
<span class="nc" id="L149">    return features.stream()</span>
<span class="nc" id="L150">        .map(</span>
            f -&gt; {
<span class="nc" id="L152">              Geometry featureGeometry = (Geometry) f.getDefaultGeometry();</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">              if (featureGeometry.intersects(geometry)) {</span>
<span class="nc" id="L154">                return Pair.of(f, featureGeometry.intersection(geometry).getArea());</span>
              } else {
<span class="nc" id="L156">                return null;</span>
              }
            })
<span class="nc" id="L159">        .filter(Objects::nonNull)</span>
<span class="nc" id="L160">        .sorted(comparingDouble((Pair&lt;SimpleFeature, Double&gt; p) -&gt; p.getRight()).reversed())</span>
<span class="nc" id="L161">        .map(Pair::getLeft)</span>
<span class="nc" id="L162">        .collect(Collectors.toList());</span>
  }

  // See https://www.w3.org/TR/sdw-bp/#applicability-formatVbp, use text/plain content type for WKT
  // in request body
  @PostMapping(
      path = &quot;${planmonitor-wonen-api.base-path}/planregistratie/autofill-by-geometry&quot;,
      consumes = &quot;text/plain&quot;)
  public Map&lt;String, Object&gt; autofill(@RequestBody String wkt) {
    Geometry geometry;
    try {
<span class="nc" id="L173">      GeometryFactory geometryFactory = new GeometryFactory(new PrecisionModel(), 28992);</span>
<span class="nc" id="L174">      geometry = new WKTReader(geometryFactory).read(wkt);</span>
<span class="nc" id="L175">    } catch (ParseException e) {</span>
<span class="nc" id="L176">      throw new ResponseStatusException(BAD_REQUEST, &quot;WKT parsing error&quot;);</span>
<span class="nc" id="L177">    }</span>

<span class="nc" id="L179">    List&lt;String&gt; gemeentes =</span>
        this.jdbcClient
<span class="nc" id="L181">            .sql(</span>
                &quot;&quot;&quot;
        select g.naam
        from gemeente g
        where st_intersects(g.geometry, st_geomfromtext(?, 28992))
        order by st_area(st_intersection(g.geometry, st_geomfromtext(?, 28992))) desc&quot;&quot;&quot;)
<span class="nc" id="L187">            .param(wkt)</span>
<span class="nc" id="L188">            .param(wkt)</span>
<span class="nc" id="L189">            .query(String.class)</span>
<span class="nc" id="L190">            .list();</span>

<span class="nc" id="L192">    List&lt;String&gt; provincies =</span>
<span class="nc" id="L193">        getFeaturesOrderedByIntersectionAreaDescending(geometry, provincieFeatures).stream()</span>
<span class="nc" id="L194">            .map(f -&gt; (String) f.getAttribute(provinciesPropertyName))</span>
<span class="nc" id="L195">            .toList();</span>

<span class="nc" id="L197">    List&lt;String&gt; regios =</span>
<span class="nc" id="L198">        getFeaturesOrderedByIntersectionAreaDescending(geometry, regioFeatures).stream()</span>
<span class="nc" id="L199">            .map(f -&gt; (String) f.getAttribute(regiosPropertyName))</span>
<span class="nc" id="L200">            .toList();</span>

<span class="nc" id="L202">    List&lt;String&gt; woonmilieus =</span>
<span class="nc" id="L203">        getFeaturesOrderedByIntersectionAreaDescending(geometry, woonmilieuFeatures).stream()</span>
<span class="nc" id="L204">            .map(f -&gt; (Integer) f.getAttribute(woonmilieuPropertyName))</span>
<span class="nc" id="L205">            .distinct()</span>
<span class="nc" id="L206">            .map(PlanregistratieAutofillController::woonmilieuCodeToEnumValue)</span>
<span class="nc" id="L207">            .toList();</span>

<span class="nc" id="L209">    return Map.of(</span>
        &quot;gemeentes&quot;, gemeentes,
        &quot;provincies&quot;, provincies,
        &quot;regios&quot;, regios,
        &quot;woonmilieus&quot;, woonmilieus);
  }

<span class="nc" id="L216">  private static final Map&lt;Integer, String&gt; woonmilieuCodeValueMap =</span>
<span class="nc" id="L217">      Map.of(</span>
<span class="nc" id="L218">          2, &quot;Centrum&quot;,</span>
<span class="nc" id="L219">          6, &quot;Stedelijk Compact&quot;,</span>
<span class="nc" id="L220">          7, &quot;Stedelijk Grondgebonden&quot;,</span>
<span class="nc" id="L221">          8, &quot;Stedelijk met Groen&quot;,</span>
<span class="nc" id="L222">          9, &quot;Landelijk of Dorps bij de stad&quot;,</span>
<span class="nc" id="L223">          10, &quot;Dorps&quot;,</span>
<span class="nc" id="L224">          11, &quot;Landelijk&quot;);</span>

  private static String woonmilieuCodeToEnumValue(Integer code) {
<span class="nc" id="L227">    return Objects.requireNonNullElse(woonmilieuCodeValueMap.get(code), &quot;Geen Woonmilieu&quot;);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>